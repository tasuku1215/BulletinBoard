ポインター　

〇ポインターの性質と使い方
・ポインターを1進めると、値はそのポインターの型サイズ分だけ進む。

int a[5] = {1,2,3,4,5};
int *p;
p = a;　//又はp=&a[0];

p++;//pはどうなる？

int型なら、4バイト進み、char型なら1バイト進む。
構造体なら、中にどんな内容があっても次の構造体まで進む。
struct a
{
	int ***
	char ***
}

atruct a b[3];
p = &b[1];
p++:

b[0]
[	int ***
	char ***
]
↓に行く。
b[1]
[
	int ***
	char *** 
]











//aをポインタだけを使って表示する。
	
	int a[4] = { 1,2,3,4 },i;
	int *p;
	p = a;

	for (i = 0; i < 4; i++)
	{
		printf("%d\n",*p);//pの内容を見たいので*pにする。pにするとアドレスが出てくる。
		p++;
	}
	

	
	int i;
	char a[] = "ABCD";
	char *p;
	p = a;

	for (i = 0; i < 4; i++)
	{
		printf("%s\n",p);
		p++;
	}


＊＊＊＊＊＊＊＊＊＊＊＊＊
printf("%s",p)でもできる！

%sはアドレスを要求するので、文字列として表示できる。
(%c : c= char(一文字))
(%s : s= string(文字列))




・二次元配列とポインター
int i,j;
int a[2][2]={{1,2},{3,4}};
int *p=a[0];
(このあとで1,2,3,4をprintfする)







・構造体とポインター
struct a{
	char name[20];
	char ken[15];
	int toshi;
}aa;//インスタント(実体)

struct a *p;
p = &aa;


p->name//->これをアロー演算子と呼ぶ。
p->ken
p->toshi


構造体のメンバー変数(内容)をアクセスするときは、
・ポインタを使わないときはドット演算子(aa.name)
・ポインタを使うときはアロー演算子(p->)でアクセス。


＊ただし、構造体の中に構造体がある場合、最初の構造体のメンバー変数にはアロー演算子で、その中の構造体のメンバー変数にはドット演算子でアクセス。












