09.Pointer
(1)変数のアドレス
	メモリー上の住所。
	リンカーが割り当てられる。
	(a)変数のアドレスはどうすれば分かる？
	int a;　→&aとすればaのアドレスを示す。
		　scanf("%d",&a);aのアドレスを引数で渡している。
	int a[5][10]→scanf("%d",&[3][7]);
		配列の先頭だけは&が無くても良い
			scanf("%d",a[2]);　　//&a[2][0]としても良い。



(2)なぜアドレスを知る必要があるのか？
	関数の中でその変数の内容を書き換える必要がある時、アドレスが必要になる。
		printf("%d",a);//これは書き換えではなく、ただ表示しているだけなので&はいらない。

〇関数について


void main(void)
{
	int a=100;
	sub(a);//下の関数を読みに行く。　　aの内容のコピーが渡される。コピー渡し関数(内容のコピーが渡されるだけ)
	printf("%d",a);//答えは100のまま。

}
	↓
int rtn;
rtn=sub(a);
printf("%d",rtn);//101になる。




戻り値	引数の型と引数。
void sub(int a)
{
	a++;
}

	↓

int sub(int a)//戻り値はvoidではなく、int型である。
{
	a++;
	return a;

}


























〇Pointer変数
メモリアドレスを記憶する為の変数。
int *p;//int型の変数のアドレスを記憶
cahar *p;//cahr型の変数のアドレスを記憶



int a=100;
int *p;
p=&a;//pにはaのアドレスが入る。



cahr b='A';
char *p;
p=&b;



*pの*はアドレスポインターを示す為の単なる「記号」
pがアドレスを入れるための箱であることを示す。




char a[]="ABC";
char *p;
p=a;//配列の先頭だけはアドレスを示すので&はいらない。なので、p　=　&a[0]としても同じ。




・pの示すアドレスにデータを代入する
int a=100;
int *p;
p=&a;


aを使わずにint aの内容を書き換えたい。
*p=200;//pのアドレスが示す内容。	*→間接参照演算子


＊＊＊＊＊int *pとは関係ない！＊＊＊＊＊＊＊＊
printf("%d",a);//=200



int *p=&aとかしてもいい。







